using System;
using System.Collections.Generic;
using System.IO;
using System.Linq;
using System.Text;
using System.Threading.Tasks;
using System.Xml;

namespace Compiler
{
    /// <summary>
    //////////////////////////////////////////////////////////////////////////////////////
    //This is v2 of CompilationEngine.cs - XML parse tree generation with identifier info.
    //////////////////////////////////////////////////////////////////////////////////////
    /// 
    ///  Recursive top-down parser.
    ///  
    ///  Effects the actual compilation output.
    ///  Gets its input from a JackTokenizer and emits its parsed structure into an output file/stream.
    ///  The output is generated by a series of compilexxx() routines, one for every syntactic element xxx of the Jack grammar.
    ///  The contract between these routines is that each compilexxx() routine should read the syntactic construct xxx
    ///  from the input, advance() the tokenizer exactly beyond xxx, and output the parsing of xxx.
    ///  Thus, compilexxx() may only be called if indeed xxx is the next syntactic element of the input.
    ///  
    /// The current version of the Compiler doesn't handle duplicate variables/arguments:
    /// E.g.: var int x, x;
    /// E.g.: constructor Square new(int x, string x).
    /// </summary>
    public class CompilationEngine : IDisposable
    {
        #region TokenizerStatePerMethod
        /*
         * This section specifies, for each method, if the Tokenizer needs to advance
         * (1: yes, 0: no, ?: undetermined i.e. depends on conditions in the method/parameters passed to the method)
         * when the method starts executing and right after the method finished executing.
         * 
         * E.g. f: 10 means:
         * - when f starts executing, the current token has been processed and thus, the Tokenizer needs to advance;
         * - right after f finishes executing, the current token has been advanced to but not processed and thus,
         *      at this point, the Tokenizer should not advance, or else it'll skip one token.
         * 
         * CompileClass - 11
         * CompileClassVarDec - 01
         * CompileClassBody - 11
         * CompileSubroutine - 01
         * CompileParameterList - 10
         * CompileSubroutineBody - 11
         * CompileVarDec - 01
         * 
         * CompileStatements - 00
         * CompileLet - 11
         * CompileIf - 11
         * CompileWhile - 11
         * CompileDo - 11
         * CompileReturn - 11
         * 
         * CompileExpression - 10
         * CompileTerm - 11
         * CompileSubroutineCall - ?1
         * CompileExpressionList - 1?
         * 
         * AdvanceIfMoreTokens - 10
         * IfAdvanceToken - ?0
         * WriteTerminal - 01
         * CompileSymbol - ?1
         * IsOp - 00
         * IsUnaryOp - 00
         * IsKeywordConstant - 00
         * TryCompileVarList - 10
         * IsValidType - 00
         * IsValidExpressionStart - 11
         * CompileVarListWithTerminator - 11
         * CompileExpressionWithinRoundBrackets - ?1
         * CompileExpressionWithinSquareBrackets - 11
         * CompileExpressionListWithinRoundBrackets - 01
         * CompileStatementsWithinCurlyBrackets - 11
         * CompileConditionalStatementConstruct - 11
         * CompileSubroutineNameWithExpressionList - 11
         * CompileTermBeginningWithIdentifier - 01
         * 
         */

        #endregion

        private JackTokenizer tokenizer;
        private Token_Type tokenType;
        private XmlWriter writer;

        /// <summary>
        /// Creates a new compilation engine with the given input and output.
        /// The next routine called must be CompileClass(). 
        /// </summary>
        /// <param name="inputStream"> A junk-free Jack file stream.</param>
        /// <param name="outputStream"> A parsed Jack file xml stream.</param>
        public CompilationEngine(MemoryStream tokensInputStream, ref MemoryStream parsedJackFileXml)
        {
            XmlWriterSettings settings = new XmlWriterSettings();
            // The Unicode encoding ensures that the following Jack tokens: '<', '>', '"' and '&',
            // which are also used for XML markup, are output as '&lt;', '&gt;', '&quot;', and '&amp;', respectively. 
            settings.Encoding = Encoding.Unicode;
            settings.Indent = true;
            //settings.NewLineOnAttributes = true;
            //settings.ConformanceLevel = ConformanceLevel.Fragment;
            settings.OmitXmlDeclaration = true;
            
            using (tokenizer = new JackTokenizer(tokensInputStream))
            {
                using(writer = XmlWriter.Create(parsedJackFileXml, settings))
                {
                    CompileClass();
                }
            }       
        }

        #region ProgramStructureRules

        /// <summary>
        /// Compiles a complete class.
        /// </summary>
        private void CompileClass()
        {
            SymbolTable.StartClass();

            writer.WriteStartElement("class");
            // Parse CLASS keyword.
            if (AdvanceIfMoreTokens() && tokenType == Token_Type.KEYWORD && tokenizer.Keyword() == Keyword.CLASS)
            {                
                WriteTerminal("keyword", tokenizer.CurrentToken);
            }
            else
            {
                throw new Exception("Unexpected end of file.");
            }

            // Parse className.
            if (AdvanceIfMoreTokens() && tokenType == Token_Type.IDENTIFIER)
            {
                string idenCat = Token.idenCatToStringDictionary[IdentifierCategory.CLASS];
                WriteIdentifier(tokenizer.CurrentToken, idenCat, true, -1);
            }
            else
            {
                throw new Exception("Invalid class name.");
            }

            CompileClassBody();           
            writer.WriteFullEndElement();                      
        }

        /// <summary>
        /// Compiles a static declaration or a field declaration.
        /// </summary>
        private void CompileClassVarDec()
        {            
            writer.WriteStartElement("classVarDec");
            WriteTerminal("keyword", tokenizer.CurrentToken);
            CompileVarListWithTerminator();    
            writer.WriteFullEndElement();
        }

        /// <summary>
        /// Compiles the body of a class.
        /// </summary>
        private void CompileClassBody()
        {
            // Parse symbol '{'.
            CompileSymbol(true, Symbol.OpeningCurlyBracket, "'{' expected in class declaration.");

            bool isKeyword = true;
            Keyword keyword;
            // Parse classVarDec*.
            while (AdvanceIfMoreTokens())
            {
                if (tokenType == Token_Type.KEYWORD)
                {
                    keyword = tokenizer.Keyword();
                    if (keyword == Keyword.STATIC || keyword == Keyword.FIELD)
                    {
                        CompileClassVarDec();
                    }
                    else
                    {
                        break;
                    }
                }
                else
                {
                    isKeyword = false;
                    break;
                }
            }

            if (isKeyword)
            {
                // Parse subroutineDec*.
                do
                {
                    keyword = tokenizer.Keyword();
                    if (keyword == Keyword.CONSTRUCTOR || keyword == Keyword.FUNCTION || keyword == Keyword.METHOD)
                    {
                        CompileSubroutine();
                    }
                    else
                    {
                        break;
                    }
                }
                while (AdvanceIfMoreTokens() && tokenType == Token_Type.KEYWORD);
            }

            // Parse symbol '}'.
            CompileSymbol(false, Symbol.ClosingCurlyBracket, "'}' expected in class declaration."); 
        }

        /// <summary>
        /// Compiles a complete method, function, or constructor.
        /// </summary>
        private void CompileSubroutine()
        {
            SymbolTable.StartSubroutine();

            writer.WriteStartElement("subroutineDec");
            WriteTerminal("keyword", tokenizer.CurrentToken);

            // Parse 'void'|type.
            if (AdvanceIfMoreTokens())
            {
                if (tokenType == Token_Type.KEYWORD && tokenizer.Keyword() == Keyword.VOID)
                {
                    WriteTerminal("keyword", tokenizer.CurrentToken);
                }
                else if (IsValidType())
                {
                    WriteDataTypeTerminal(tokenizer.CurrentToken);                    
                }
                else
                {
                    throw new Exception("Invalid subroutine type.");
                }
            }
            else
            {
                throw new Exception("Invalid subroutine type.");
            }

            // Parse subroutineName.
            if (AdvanceIfMoreTokens() && tokenType == Token_Type.IDENTIFIER)
            {
                string idenCategoryString = Token.idenCatToStringDictionary[IdentifierCategory.SUBROUTINE];
                WriteIdentifier(tokenizer.CurrentToken, idenCategoryString, true, -1);               
            }
            else
            {
                throw new Exception("Invalid subroutine name.");
            }

            // Parse symbol '('.
            CompileSymbol(true, Symbol.OpeningRoundBracket, "'(' expected in subroutine declaration.");

            // Parse: ((type varName) (',' type varName)*)?.
            CompileParameterList();

            // Parse symbol ')'.
            CompileSymbol(false, Symbol.ClosingRoundBracket, "')' expected in variable declaration.");

            CompileSubroutineBody();

            writer.WriteFullEndElement();
        }

        /// <summary>
        /// Compiles a (possibly empty) parameter list, not including the enclosing “()”. 
        /// </summary>
        private void CompileParameterList()
        {
            writer.WriteStartElement("parameterList");
            
            // Parse type.
            if (AdvanceIfMoreTokens() && IsValidType())
            {
                string idenName;
                string listVarType = tokenizer.CurrentToken;
                WriteDataTypeTerminal(listVarType);

                string idenCategoryString = Token.idenCatToStringDictionary[IdentifierCategory.ARG];

                // Parse varName.
                if (AdvanceIfMoreTokens() && tokenType == Token_Type.IDENTIFIER)
                {
                    idenName = tokenizer.CurrentToken;
                    StoreAndWriteIdentifier(idenName, listVarType, IdentifierCategory.ARG,
                        idenCategoryString, true);                    
                }
                else
                {
                    throw new Exception("Invalid subroutine name.");
                }

                // Parse (',' type varName)*.
                while (AdvanceIfMoreTokens())
                {
                    if (tokenType == Token_Type.SYMBOL && tokenizer.Symbol() == Symbol.Comma)
                    {
                        WriteTerminal("symbol", tokenizer.CurrentToken);
                        if (AdvanceIfMoreTokens() && IsValidType())
                        {
                            WriteDataTypeTerminal(tokenizer.CurrentToken);
                            if (AdvanceIfMoreTokens() && tokenType == Token_Type.IDENTIFIER)
                            {
                                StoreAndWriteIdentifier(tokenizer.CurrentToken, listVarType, IdentifierCategory.ARG,
                                    idenCategoryString, true);
                            }
                            else
                            {
                                throw new Exception("Invalid parameter list.");
                            }
                        }
                        else
                        {
                            throw new Exception("Invalid parameter list.");
                        }
                    }
                    else
                    {
                        break;
                    }
                }
            }

            writer.WriteFullEndElement();
        }

        /// <summary>
        /// Compiles the body of a method, function, or constructor.
        /// </summary>
        private void CompileSubroutineBody()
        {
            writer.WriteStartElement("subroutineBody");

            // Parse symbol '{'.
            CompileSymbol(true, Symbol.OpeningCurlyBracket, "'{' expected in subroutine declaration.");            

            // Parse varDec*.
            while (AdvanceIfMoreTokens())
            {
                if (tokenType == Token_Type.KEYWORD)
                {
                    Keyword keyword = tokenizer.Keyword();
                    if (keyword == Keyword.VAR)
                    {
                        CompileVarDec();
                    }
                    else
                    {
                        break;
                    }
                }
                else
                {
                    break;
                }
            }

            // Parse statements.
            CompileStatements();

            // Parse symbol '}'.
            CompileSymbol(false, Symbol.ClosingCurlyBracket, "'}' expected in subroutine body declaration.");            

            writer.WriteFullEndElement();
        }        

        /// <summary>
        /// Compiles a var declaration.
        /// </summary>
        private void CompileVarDec()
        {
            writer.WriteStartElement("varDec");
            WriteTerminal("keyword", tokenizer.CurrentToken);
            CompileVarListWithTerminator();            
            writer.WriteFullEndElement();
        }
        
        #endregion

        #region StatementRules

        /// <summary>
        /// Compiles a sequence of statements, not including the enclosing “{}”. 
        /// </summary>
        private void CompileStatements()
        {
            writer.WriteStartElement("statements");

            // Parse statement*.
            do
            {
                if (tokenType == Token_Type.KEYWORD)
                {
                    Keyword keyword = tokenizer.Keyword();
                    
                    if (keyword == Keyword.LET)
                    {
                        CompileLet();
                    }
                    else if (keyword == Keyword.IF)
                    {
                        CompileIf();                        
                    }
                    else if (keyword == Keyword.WHILE)
                    {
                        CompileWhile();
                    }
                    else if (keyword == Keyword.DO)
                    {
                        CompileDo();
                    }
                    else if (keyword == Keyword.RETURN)
                    {
                        CompileReturn();
                    }
                    else
                    {
                        break;
                    }
                }
                else
                {
                    break;
                }
            }
            while (AdvanceIfMoreTokens());            

            writer.WriteFullEndElement();
        }

        /// <summary>
        /// Compiles a LET statement. 
        /// </summary>
        private void CompileLet()
        {
            writer.WriteStartElement("letStatement");
            WriteTerminal("keyword", tokenizer.CurrentToken);

            // Parse varName.
            if (AdvanceIfMoreTokens() && tokenType == Token_Type.IDENTIFIER)
            {
                WriteIdentifierIfItExists(tokenizer.CurrentToken);
            }
            else
            {
                throw new Exception("Invalid LET statement declaration.");
            }

            bool advanceToken = false;
            // Parse ('['expression']')?.
            // Parse symbol '['.
            if (AdvanceIfMoreTokens() && tokenType == Token_Type.SYMBOL && tokenizer.Symbol() == Symbol.OpeningSquareBracket)
            {
                WriteTerminal("symbol", tokenizer.CurrentToken);
                // Parse expression.                
                CompileExpression();
                // Parse symbol ']'.
                CompileSymbol(false, Symbol.ClosingSquareBracket, "Invalid LET statement declaration.");
                advanceToken = true;
            }

            // Parse symbol '='.
            CompileSymbol(advanceToken, Symbol.EqualSign, "'=' expected in LET statement declaration.");

            // Parse expression.
            CompileExpression();

            // Parse symbol ';'.
            CompileSymbol(false, Symbol.Semicolon, "';' expected in LET statement declaration.");

            writer.WriteFullEndElement();
        }

        /// <summary>
        /// Compiles an IF statement, possibly with a trailing ELSE clause.
        /// </summary>
        private void CompileIf()
        {
            writer.WriteStartElement("ifStatement");
            WriteTerminal("keyword", tokenizer.CurrentToken);

            // Parse '('expression')' '{'statements'}'.
            CompileConditionalStatementConstruct();            
            
            // An ELSE clause may appear 0 or 1 time. Regardless, at the end of this function, the current token must have
            // been processed. That's why a peek to the next token is needed.
            // The tokenizer advances only if the next token is 'else'.

            // Parse: ('else' '{'statements'}')?.
            if (tokenizer.HasMoreTokens())
            {
                KeyValuePair<string, Token_Type> nextToken = tokenizer.Peek();
                string nextTokenString = nextToken.Key;
                Token_Type nextTokenType = nextToken.Value;
                if (nextTokenType == Token_Type.KEYWORD && tokenizer.PeekKeyword(nextTokenString) == Keyword.ELSE)
                {
                    tokenizer.Advance();
                    WriteTerminal("keyword", tokenizer.CurrentToken);
                    // Parse '{'statements'}'.
                    CompileStatementsWithinCurlyBrackets();
                }
            }            

            writer.WriteFullEndElement();
        }

        /// <summary>
        /// Compiles a WHILE statement.
        /// </summary>
        private void CompileWhile()
        {
            writer.WriteStartElement("whileStatement");
            WriteTerminal("keyword", tokenizer.CurrentToken);

            // Parse '('expression')' '{'statements'}'.
            CompileConditionalStatementConstruct();

            writer.WriteFullEndElement();
        }

        /// <summary>
        /// Compiles a DO statement.
        /// </summary>
        private void CompileDo()
        {
            writer.WriteStartElement("doStatement");
            WriteTerminal("keyword", tokenizer.CurrentToken);

            // Parse subroutine call.
            CompileSubroutineCall(true);
            // Parse symbol ';'.
            CompileSymbol(true, Symbol.Semicolon, "';' expected in DO statement declaration.");

            writer.WriteFullEndElement();
        }

        /// <summary>
        /// Compiles a RETURN statement.
        /// </summary>
        private void CompileReturn()
        {
            writer.WriteStartElement("returnStatement");
            WriteTerminal("keyword", tokenizer.CurrentToken);

            bool advanceToken = true;
            // Parse expression?.
            if (IsValidExpressionStart())
            {
                // Parse expression.
                CompileExpression();
                advanceToken = false;
            }
            // Parse symbol ';'.
            CompileSymbol(advanceToken, Symbol.Semicolon, "';' expected in RETURN statement declaration.");

            writer.WriteFullEndElement();
        }

        #endregion

        #region ExpressionRules

        /// <summary>
        /// Compiles an expression.
        /// </summary>
        private void CompileExpression()
        {
            writer.WriteStartElement("expression");

            // Parse term.
            CompileTerm();

            // Parse (op term)*.
            while (AdvanceIfMoreTokens())
            {
                if (tokenType == Token_Type.SYMBOL && IsOp())
                {
                    WriteTerminal("symbol", tokenizer.CurrentToken);
                    CompileTerm();
                }
                else
                {
                    break;
                }
            }

            writer.WriteFullEndElement();
        }

        /// <summary>
        /// Compiles a term.
        /// </summary>
        private void CompileTerm()
        {
            writer.WriteStartElement("term");

            // Parse 
            // integerConstant | stringConstant | keywordConstant | varName |
            // varName '[' expression ']' | subroutineCall | '(' expression ')' | unaryOp term.
            if (AdvanceIfMoreTokens())
            {
                Token_Type tokenType = tokenizer.TokenType();
                
                if (tokenType == Token_Type.INT_CONST)
                {                    
                    WriteTerminal("integerConstant", tokenizer.CurrentToken);
                }
                else if(tokenType == Token_Type.STRING_CONST)
                {
                    WriteTerminal("stringConstant", tokenizer.StringVal());
                }
                else if (tokenType == Token_Type.KEYWORD && IsKeywordConstant())
                {
                    WriteTerminal("keyword", tokenizer.CurrentToken);
                }
                else if (tokenType == Token_Type.IDENTIFIER)
                {
                    CompileTermBeginningWithIdentifier();                 
                }
                else if (tokenType == Token_Type.SYMBOL)
                {
                    if (tokenizer.Symbol() == Symbol.OpeningRoundBracket)
                    {
                        // Parse '(' expression ')'.
                        CompileExpressionWithinRoundBrackets(false);
                    }
                    else if (IsUnaryOp())
                    {
                        // Parse unaryOp term.
                        WriteTerminal("symbol", tokenizer.CurrentToken);
                        CompileTerm();
                    }
                    else
                    {
                        throw new Exception("Invalid term.");
                    }
                }
                else
                {
                    throw new Exception("Invalid term.");
                }
            }
            else
            {
                throw new Exception("Term expected in expression declaration.");
            }

            writer.WriteFullEndElement();
        }        

        /// <summary>
        /// Compiles a subroutine call.
        /// This method needs to call <see cref="AdvanceIfMoreTokens()"/> if the current token has been processed.
        /// Otherwise, it can process the current token.
        /// </summary>
        /// <param name="advanceToken"> True, if the tokenizer needs to advance to the next token; false, otherwise.</param>
        private void CompileSubroutineCall(bool advanceToken)
        {
            bool hasMoreTokens = IfAdvanceToken(advanceToken);

            // Parse: subroutineName|className|varName.
            if (hasMoreTokens && tokenType == Token_Type.IDENTIFIER)
            {                
                string idenName = tokenizer.CurrentToken;
                if (AdvanceIfMoreTokens())
                {
                    // Parse symbol '.'.
                    if (tokenType == Token_Type.SYMBOL && tokenizer.Symbol() == Symbol.Period)
                    {
                        // At this point, the identifier is either className or varName.
                        string idenCatString;
                        int idenIndex;
                        // If the identifier exists in the symbol table, it's a varName.
                        bool isVarName = TryGetIdentifierInfo(idenName, out idenCatString, out idenIndex);

                        if (isVarName)
                        {
                            // The identifier is a varName.
                            WriteIdentifier(idenName, idenCatString, false, idenIndex);
                        }
                        else
                        {
                            // The identifier is a className.
                            string idenCat = Token.idenCatToStringDictionary[IdentifierCategory.CLASS];
                            WriteIdentifier(idenName, idenCat, false, -1);
                        }

                        WriteTerminal("symbol", tokenizer.CurrentToken);

                        // Parse: subroutineName '('expressionList')'.
                        CompileSubroutineNameWithExpressionList();
                    }
                    else
                    {
                        // Parse subroutineName.
                        string idenCategoryString = Token.idenCatToStringDictionary[IdentifierCategory.SUBROUTINE];
                        WriteIdentifier(idenName, idenCategoryString, false, -1);

                        // Parse '('expressionList')'.
                        CompileExpressionListWithinRoundBrackets();
                    }
                }
                else
                {
                    throw new Exception("'.' or '(' expected in subroutine call.");
                }
            }
            else
            {
                throw new Exception("Invalid subroutine call.");
            }
        }

        /// <summary>
        /// Compiles a (possibly empty) comma-separated list of expressions.
        /// </summary>
        private void CompileExpressionList(out bool tokenAdvance)
        {
            writer.WriteStartElement("expressionList");

            tokenAdvance = true;
            // Parse (expression (',' expression)*)?.
            if (IsValidExpressionStart())
            {
                tokenAdvance = false;

                // Parse expression.
                CompileExpression();

                // Parse (',' expression)*.
                do
                {
                    if (tokenType == Token_Type.SYMBOL && tokenizer.Symbol() == Symbol.Comma)
                    {
                        WriteTerminal("symbol", tokenizer.CurrentToken);
                        // Parse expression.
                        CompileExpression();
                    }
                    else
                    {                        
                        break;
                    }
                }
                while (tokenizer.HasMoreTokens());
            }

            writer.WriteFullEndElement();
        }

        #endregion

        #region HelperMethods

        /// <summary>
        /// If there are more tokens in the file, advances the tokenizer and gets the type of the current token.
        /// </summary>
        /// <returns> True, if there are more tokens; false, otherwise.</returns>
        private bool AdvanceIfMoreTokens()
        {
            if (tokenizer.HasMoreTokens())
            {
                tokenizer.Advance();
                tokenType = tokenizer.TokenType();
                return true;
            }

            return false;
        }

        /// <summary>
        /// Checks if the tokenizer can advance (if it needs to) to the next token.
        /// </summary>
        /// <param name="advanceToken"> True, if the tokenizer needs to advance to the next token; false, otherwise.</param>
        /// <returns> True, if the tokenizer needs to and can advance to the next token; false, otherwise.</returns>
        private bool IfAdvanceToken(bool advanceToken)
        {
            if (advanceToken && !AdvanceIfMoreTokens())
            {
                return false;
            }
            return true;
        }

        /// <summary>
        /// Writes an XML element representing a terminal with the specified type and value.
        /// </summary>
        /// <param name="type"> Terminal type.</param>
        /// <param name="terminal"> Terminal value.</param>
        private void WriteTerminal(string type, string terminal)
        {
            writer.WriteStartElement(type);
            writer.WriteValue(" " + terminal + " ");
            writer.WriteFullEndElement();
        }

        /// <summary>
        /// Writes an XML element representing an identifier or a KEYWORD terminal, based on the token type.
        /// </summary>
        /// <param name="dataTypeString"> The data type.</param>        
        private void WriteDataTypeTerminal(string dataTypeString)
        {            
            if (tokenType == Token_Type.IDENTIFIER)
            {
                string idenCat = Token.idenCatToStringDictionary[IdentifierCategory.CLASS];
                WriteIdentifier(dataTypeString, idenCat, false, -1);
            }
            else
            {
                WriteTerminal("keyword", dataTypeString);
            }
        }

        /// <summary>
        /// Writes an XML element representing an identifier with the specified parameters:
        ///     - the identifier name;
        ///     - the identifier category (var, arg, static, field, class, subroutine);
        ///     - whether the identifier is presently being defined
        ///         (e.g., the identifier stands for a variable declared in a var statement) or
        ///         used (e.g., the identifier stands for a variable in an expression);
        ///     - the running index assigned to the identifier by the symbol table
        ///         (-1, if the identifier represents a class or subroutine variable).
        /// </summary>
        /// <param name="name"> The identifier name.</param>
        /// <param name="category"> The identifier category.</param>
        /// <param name="isDefined"> The identifier status: defined or used.</param>
        /// <param name="runningIndex"> The identifier running index in current scope.</param>
        private void WriteIdentifier(string name, string category, bool isDefined, int runningIndex)
        {
            writer.WriteStartElement("identifier");
            WriteTerminal("name", name);
            WriteTerminal("category", category);
            WriteTerminal("isDefined", isDefined.ToString());
            WriteTerminal("runningIndex", runningIndex.ToString());
            writer.WriteFullEndElement();
        }

        #region MethodsForCheckingDuplicateVars
        ///// <summary>
        ///// Tries to store the identifier info in the symbol table, based on the specified parameters.
        ///// </summary>
        ///// <param name="idenName"> The identifier name.</param>
        ///// <param name="idenCatString"> The identifier category string.</param>
        ///// <param name="idenIndex"> The identifier running index.</param>
        ///// <returns> True, if identifier info is not present in the symbol table; false, otherwise.</returns>
        //private bool TryStoreIdentifierInfo(string idenName, string idenDataType, IdentifierCategory idenCat)
        //{
        //    IdentifierCategory idenKind = SymbolTable.KindOf(idenName);
        //    if (idenKind == IdentifierCategory.NONE)
        //    {
        //        SymbolTable.Define(idenName, idenDataType, idenCat);
        //        return true;
        //    }
        //    return false;
        //}

        ///// <summary>
        ///// If the identifier specified by the given parameters doesn't exist in the symbol table (i.e. it's not a duplicate),
        ///// adds this identifier info to the symbol table and writes it to the XML.
        ///// Else, throws an exception.
        ///// </summary>
        ///// <param name="idenName"> The identifier name.</param>
        ///// <param name="idenDataType"> The identifier data type.</param>
        ///// <param name="idenCat"> The identifier category.</param>
        ///// <param name="idenCatString"> The identifier category string.</param>
        ///// <param name="isIdenDefined"> The identifier status: defined or used.</param>
        ///// <param name="exMessage"> The exception message to be displayed in case the identifier is a duplicate.</param>
        //private void StoreAndWriteIdentifierIfItsNotDuplicate(string idenName, string idenDataType, IdentifierCategory idenCat,
        //    string idenCatString, bool isIdenDefined, string exMessage="")
        //{
        //    bool isNotDuplicate = TryStoreIdentifierInfo(idenName, idenDataType, idenCat);
        //    if (isNotDuplicate)
        //    {                
        //        WriteIdentifier(idenName, idenCatString, isIdenDefined, SymbolTable.IndexOf(idenName));
        //    }
        //    else
        //    {
        //        throw new Exception(exMessage);
        //    }
        //}
        #endregion

        /// <summary>
        /// Stores the identifier info in the symbol table, based on the specified parameters.
        /// Writes the identifier info to the XML.
        /// </summary>
        /// <param name="idenName"> The identifier name.</param>
        /// <param name="idenDataType"> The identifier data type.</param>
        /// <param name="idenCat"> The identifier category.</param>
        /// <param name="idenCatString"> The identifier category string.</param>
        /// <param name="isIdenDefined"> The identifier status: defined or used.</param>
        private void StoreAndWriteIdentifier(string idenName, string idenDataType, IdentifierCategory idenCat,
            string idenCatString, bool isIdenDefined)
        {
            SymbolTable.Define(idenName, idenDataType, idenCat);
            WriteIdentifier(idenName, idenCatString, isIdenDefined, SymbolTable.IndexOf(idenName));
        }

        /// <summary>
        /// Tries to retrieve the identifier info from the symbol table, based on the specified parameter.
        /// </summary>
        /// <param name="idenName"> The identifier name.</param>
        /// <param name="idenCatString"> The identifier category string.</param>
        /// <param name="idenIndex"> The identifier running index.</param>
        /// <returns> True, if identifier info is successfully retrieved; false, otherwise.</returns>
        private bool TryGetIdentifierInfo(string idenName, out string idenCatString, out int idenIndex)
        {            
            idenCatString = "";
            idenIndex = -1;
            IdentifierCategory idenCat = SymbolTable.KindOf(idenName);
            if (idenCat != IdentifierCategory.NONE)
            {
                idenCatString = Token.idenCatToStringDictionary[idenCat];
                idenIndex = SymbolTable.IndexOf(idenName);
                return true;
            }

            return false;
        }

        /// <summary>        
        /// If the identifier specified by the given parameter exists in the symbol table, writes the identifier info to the XML.
        /// Else, throws an exception.
        /// </summary>
        /// <param name="idenName"> The identifier name.</param>       
        private void WriteIdentifierIfItExists(string idenName)
        {
            string idenCatString = "";
            int idenIndex = -1;
            bool idenExists = TryGetIdentifierInfo(idenName, out idenCatString, out idenIndex);
            if (idenExists)
            {
                WriteIdentifier(idenName, idenCatString, false, idenIndex);
            }
            else
            {
                throw new Exception("The name " + idenName + " does not exist in the current context.");
            }
        }

        /// <summary>
        /// Compiles the symbol represented by the current token.
        /// This method needs to call <see cref="AdvanceIfMoreTokens()"/> if the current token has been processed.
        /// Otherwise, it can process the current token.
        /// </summary>
        /// <param name="advanceToken"> True, if the tokenizer needs to advance to the next token; false, otherwise.</param>
        /// <param name="symbol"> The Jack symbol to be parsed.</param>
        /// <param name="exMessage"> The exception message to be displayed in case the compilation fails.</param>
        private void CompileSymbol(bool advanceToken, Symbol symbol, string exMessage)
        {
            bool hasMoreTokens = IfAdvanceToken(advanceToken);

            if (hasMoreTokens && tokenType == Token_Type.SYMBOL && tokenizer.Symbol() == symbol)
            {
                WriteTerminal("symbol", tokenizer.CurrentToken);
            }
            else
            {
                throw new Exception(exMessage);
            }
        }        

        /// <summary>
        /// Checks if the current token is a binary operator.
        /// </summary>
        /// <returns> True, if the current token is a binary operator; false, otherwise.</returns>
        private bool IsOp()
        {
            Symbol op = tokenizer.Symbol();
            if (Token.binaryOperators.Contains(op))
            {
                return true;
            }

            return false;
        }

        /// <summary>
        /// Checks if the current token is a unary operator.
        /// </summary>
        /// <returns> True, if the current token is a unary operator; false, otherwise.</returns>
        private bool IsUnaryOp()
        {
            Symbol unaryOp = tokenizer.Symbol();
            if (unaryOp == Symbol.MinusSign || unaryOp == Symbol.Tilde)
            {
                return true;
            }

            return false;
        }

        /// <summary>
        /// Checks if the current token is a keyword constant.
        /// </summary>
        /// <returns> True, if the current token is a keyword constant; false, otherwise.</returns>
        private bool IsKeywordConstant()
        {
            Keyword ct = tokenizer.Keyword();
            if (ct == Keyword.TRUE || ct == Keyword.FALSE || ct == Keyword.NULL || ct == Keyword.THIS)
            {
                return true;
            }

            return false;
        }
                
        /// <summary>
        /// Tries to compile a list of variables.
        /// </summary>        
        /// <returns> True, if the list of variables is valid; false, otherwise.</returns>
        private bool TryCompileVarList()
        {
            // The data type of the variables in the list.
            string listVarType;
            // This string is 'static'|'field' (if the list var is part of classVarDec) or 
            // 'var' (if the list var is part of varDec).
            string listVarKind = tokenizer.CurrentToken;

            // Parse type.
            if (AdvanceIfMoreTokens() && IsValidType())
            {
                listVarType = tokenizer.CurrentToken;
                WriteDataTypeTerminal(listVarType);
            }
            else
            {
                return false;
            }

            IdentifierCategory idenCategory = Token.idenStringToCatDictionary[listVarKind];

            // Parse varName.
            if (AdvanceIfMoreTokens() && tokenType == Token_Type.IDENTIFIER)
            {
                StoreAndWriteIdentifier(tokenizer.CurrentToken, listVarType, idenCategory, listVarKind, true);
            }
            else
            {
                return false;
            }

            // Parse (',' varName)*.
            while (AdvanceIfMoreTokens())
            {
                if (tokenType == Token_Type.SYMBOL && tokenizer.Symbol() == Symbol.Comma)
                {
                    WriteTerminal("symbol", tokenizer.CurrentToken);
                    if (AdvanceIfMoreTokens() && tokenType == Token_Type.IDENTIFIER)
                    {
                        StoreAndWriteIdentifier(tokenizer.CurrentToken, listVarType, idenCategory, listVarKind, true);
                    }
                    else
                    {
                        return false;
                    }
                }
                else
                {
                    break;
                }
            }

            return true;
        }

        /// <summary>
        /// Checks the validity of the type represented by the current token.
        /// </summary>
        /// <returns> True, if type is valid; false, otherwise.</returns>
        private bool IsValidType()
        {
            // Parse 'int'|'char'|'boolean'|className.
            if (tokenType == Token_Type.KEYWORD)
            {
                Keyword keyword = tokenizer.Keyword();
                if (keyword == Keyword.INT || keyword == Keyword.CHAR || keyword == Keyword.BOOLEAN)
                {                  
                    return true;
                }
            }
            else if (tokenType == Token_Type.IDENTIFIER)
            {               
                return true;
            }

            return false;
        }

        /// <summary>
        /// Checks if the next token is a valid expression start.
        /// </summary>
        /// <returns> True, if the start of the expression is valid; false, otherwise.</returns>
        private bool IsValidExpressionStart()
        {
            // Get a look-ahead token if there are more tokens.
            if (tokenizer.HasMoreTokens())
            {
                KeyValuePair<string, Token_Type> nextToken = tokenizer.Peek();
                string nextTokenString = nextToken.Key;
                Token_Type nextTokenType = nextToken.Value;

                // A valid expression can start with any token (with the exceptions below) of a valid type.
                if (nextTokenType != Token_Type.ERROR)
                {
                    if (nextTokenType == Token_Type.SYMBOL)
                    {
                        Symbol nextTokenSymbol = tokenizer.PeekSymbol(nextTokenString);
                        // If the expression starts with a symbol, it must be '(', '-' or '~'.
                        if (nextTokenSymbol != Symbol.OpeningRoundBracket && nextTokenSymbol != Symbol.MinusSign &&
                            nextTokenSymbol != Symbol.Tilde)
                        {
                            return false;
                        }
                    }

                    if (nextTokenType == Token_Type.KEYWORD)
                    {
                        Keyword nextTokenKeyword = tokenizer.PeekKeyword(nextTokenString);
                        // If the expression starts with a keyword, it must be 'true', 'false', 'null' or 'this'.
                        if (nextTokenKeyword != Keyword.TRUE && nextTokenKeyword != Keyword.FALSE &&
                            nextTokenKeyword != Keyword.NULL && nextTokenKeyword != Keyword.THIS)
                        {
                            return false;
                        }
                    }

                    return true;
                }
            }

            return false;
        }

        /// <summary>
        /// Compiles a declaration of a list of variables appended with a semicolon.
        /// </summary>
        private void CompileVarListWithTerminator()
        {
            // Parse: type varName (',' varName)* ';'.
            bool isVarList = TryCompileVarList();
            if (!isVarList)
            {
                throw new Exception("Invalid variable declaration.");
            }
            else
            {
                // Parse symbol ';'.
                CompileSymbol(false, Symbol.Semicolon, "';' expected in variable declaration.");
            }
        }

        /// <summary>
        /// Compiles an expression enclosed within round brackets.
        /// This method needs to call <see cref="AdvanceIfMoreTokens()"/> if the current token has been processed.
        /// Otherwise, it can process the current token.
        /// </summary>
        /// <param name="advanceToken"> True, if the tokenizer needs to advance to the next token; false, otherwise.</param>
        private void CompileExpressionWithinRoundBrackets(bool advanceToken)
        {
            // Parse '('expression')'.
            CompileSymbol(advanceToken, Symbol.OpeningRoundBracket, "'(' expected in statement declaration.");
            CompileExpression();
            CompileSymbol(false, Symbol.ClosingRoundBracket, "')' expected in statement declaration.");
        }

        /// <summary>
        /// Compiles an expression enclosed within square brackets.
        /// </summary>
        private void CompileExpressionWithinSquareBrackets()
        {
            // Parse '('expression')'.
            CompileSymbol(true, Symbol.OpeningSquareBracket, "'[' expected in statement declaration.");
            CompileExpression();
            CompileSymbol(false, Symbol.ClosingSquareBracket, "']' expected in statement declaration.");
        }

        /// <summary>
        /// Compiles an expressionList enclosed within round brackets.
        /// </summary>
        private void CompileExpressionListWithinRoundBrackets()
        {
            bool tokenAdvance;
            // Parse '('expressionList')'.
            CompileSymbol(false, Symbol.OpeningRoundBracket, "'(' expected in subroutine call.");
            CompileExpressionList(out tokenAdvance);
            CompileSymbol(tokenAdvance, Symbol.ClosingRoundBracket, "')' expected in subroutine call.");
        }

        /// <summary>
        /// Compiles statement(s) enclosed within curly brackets.
        /// </summary>
        private void CompileStatementsWithinCurlyBrackets()
        {
            // Parse '{'statements'}'.
            CompileSymbol(true, Symbol.OpeningCurlyBracket, "'{' expected in statement declaration.");
            if (AdvanceIfMoreTokens())
            {
                CompileStatements();
            }            
            CompileSymbol(false, Symbol.ClosingCurlyBracket, "'}' expected in statement declaration.");
        }

        /// <summary>
        /// Compiles the syntactic construct (condition followed by statement) of a conditional statement.
        /// </summary>
        private void CompileConditionalStatementConstruct()
        {
            // Parse '('expression')' '{'statements'}'.
            CompileExpressionWithinRoundBrackets(true);
            CompileStatementsWithinCurlyBrackets();
        }

        /// <summary>
        /// Compiles the syntactic construct (subroutine name followed by argument list) of a subroutine call.
        /// </summary>
        private void CompileSubroutineNameWithExpressionList()
        {
            // Parse subroutineName '('expressionList')'.
            if (AdvanceIfMoreTokens() && tokenType == Token_Type.IDENTIFIER)
            {
                string idenCategoryString = Token.idenCatToStringDictionary[IdentifierCategory.SUBROUTINE];
                WriteIdentifier(tokenizer.CurrentToken, idenCategoryString, false, -1);
                
                if (AdvanceIfMoreTokens())
                {
                    CompileExpressionListWithinRoundBrackets();
                }
                else
                {
                    throw new Exception("'(' expected in subroutine call.");
                }                
            }
            else
            {
                throw new Exception("Invalid subroutine call.");
            }
        }

        /// <summary>
        /// Compiles a term whose first token is an identifier.
        /// If the look-ahead token is “[“, the termn is an array entry.
        /// If the look-ahead token is “(“, or “.”, the termn is a subroutine call.
        /// Else, the term is a var name.
        /// </summary>
        private void CompileTermBeginningWithIdentifier()
        {            
            // Get a look-ahead token to distinguish between the alternative parsing rules.
            if (tokenizer.HasMoreTokens())
            {
                string idenName = tokenizer.CurrentToken;                

                KeyValuePair<string, Token_Type> nextToken = tokenizer.Peek();
                string nextTokenString = nextToken.Key;
                Token_Type nextTokenType = nextToken.Value;
                
                if (nextTokenType != Token_Type.ERROR)
                {
                    if (nextTokenType == Token_Type.SYMBOL)
                    {
                        Symbol nextTokenSymbol = tokenizer.PeekSymbol(nextTokenString);
                        
                        // Array entry.
                        if (nextTokenSymbol == Symbol.OpeningSquareBracket)
                        {
                            // Parse varName.
                            WriteIdentifierIfItExists(idenName);

                            // Parse '[' expression ']'.
                            CompileExpressionWithinSquareBrackets();
                        }
                        // Subroutine call. 
                        else if (nextTokenSymbol == Symbol.OpeningRoundBracket || nextTokenSymbol == Symbol.Period)
                        {
                            // The tokenizer is currently at the identifier which is the first token in the subroutine call.
                            // Since <see cref="CompileSubroutineCall(bool)"/> processes this identifier,
                            // it can't be processed in the beginning of <see cref="CompileTermBeginningWithIdentifier"/>
                            // (in case the term is a var name). So, it needs to be processed separately in the case
                            // of array entry and var name.
                            // Also, there's no need for the tokenizer to advance at this point, thus the "false" parameter.
                            CompileSubroutineCall(false);
                        }
                        // Var name.
                        else
                        {
                            // Parse varName.
                            WriteIdentifierIfItExists(idenName);
                        }
                    }
                    // Var name.
                    else
                    {
                        // Parse varName.
                        WriteIdentifierIfItExists(idenName);
                    }
                }
            }
        }

        /// <summary>
        /// Necessary because the class implements IDisposable.
        /// </summary>
        public void Dispose()
        {
        }

        #endregion
    }
}
