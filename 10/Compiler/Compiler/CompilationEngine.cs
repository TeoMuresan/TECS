using System;
using System.Collections.Generic;
using System.IO;
using System.Linq;
using System.Text;
using System.Threading.Tasks;
using VM;

namespace Compiler
{
    /// <summary>
    ///  Recursive top-down parser.
    ///  
    ///  Effects the actual compilation output.
    ///  Gets its input from a JackTokenizer and emits its parsed structure into an output file/stream.
    ///  The output is generated by a series of compilexxx() routines, one for every syntactic element xxx of the Jack grammar.
    ///  The contract between these routines is that each compilexxx() routine should read the syntactic construct xxx
    ///  from the input, advance() the tokenizer exactly beyond xxx, and output the parsing of xxx.
    ///  Thus, compilexxx() may only be called if indeed xxx is the next syntactic element of the input.
    ///  
    /// The current version of the Compiler doesn't handle duplicate variables/arguments:
    /// E.g.: var int x, x;
    ///         constructor Square new(int x, string x).
    /// </summary>
    public class CompilationEngine : IDisposable
    {
        #region TokenizerStatePerMethod
        /*
         * This section specifies, for each method, if the Tokenizer needs to advance
         * (1: yes, 0: no, ?: undetermined i.e. depends on conditions in the method/parameters passed to the method)
         * when the method starts executing and right after the method finished executing.
         * 
         * E.g. f: 10 means:
         * - when f starts executing, the current token has been processed and thus, the Tokenizer needs to advance;
         * - right after f finishes executing, the current token has been advanced to but not processed and thus,
         *      at this point, the Tokenizer should not advance, or else it'll skip one token.
         * 
         * CompileClass - 11         
         * CompileClassBody - 11
         * CompileSubroutine - 01
         * CompileParameterList - 10
         * CompileSubroutineBody - 11
         * CompileVarDec - 01
         * 
         * CompileStatements - 00
         * CompileLet - 11
         * CompileIf - 11
         * CompileWhile - 11
         * CompileDo - 11
         * CompileReturn - 11
         * 
         * CompileExpression - 10
         * CompileTerm - 11
         * CompileSubroutineCall - ?1
         * CompileExpressionList - 1?
         * 
         * AdvanceIfMoreTokens - 10
         * IfAdvanceToken - ?0         
         * CompileSymbol - ?1
         * IsOp - 00
         * IsUnaryOp - 00
         * IsKeywordConstant - 00
         * TryCompileVarList - 10
         * IsValidType - 00
         * IsValidExpressionStart - 11
         * CompileVarListWithTerminator - 11
         * CompileExpressionWithinRoundBrackets - ?1
         * CompileExpressionWithinSquareBrackets - 11
         * CompileExpressionListWithinRoundBrackets - 01
         * CompileStatementsWithinCurlyBrackets - 11         
         * CompileSubroutineNameWithExpressionList - 11
         * CompileTermBeginningWithIdentifier - 01
         * 
         */
        #endregion

        private JackTokenizer tokenizer;
        private List<string> methodNames;
        private Token_Type tokenType;
        private string currClassName;
        private SubroutineProperties currSubroutine = new SubroutineProperties();        
        private VMWriter writer;

        #region IFAndWHILELabelStringConstants       
        private const string ifFalseLabelConst = "IF_FALSE";
        private const string ifEndLabelConst = "IF_END";
        private const string whileStartLabelConst = "WHILE_EXP";
        private const string whileEndLabelConst = "WHILE_END";
        #endregion

        /// <summary>
        /// Creates a new compilation engine with the given input and output.
        /// The next routine called must be CompileClass(). 
        /// </summary>
        /// <param name="tokensInputStream"> A junk-free Jack file stream.</param>
        /// <param name="vmOutputStream"> The VM file stream corresponding to the compiled Jack file stream.</param>
        public CompilationEngine(MemoryStream tokensInputStream, ref MemoryStream vmOutputStream)
        {                        
            using (tokenizer = new JackTokenizer(tokensInputStream))
            {
                using(writer = new VMWriter(vmOutputStream))
                {
                    CompileClass();
                }
            }       
        }

        #region ProgramStructureRules

        /// <summary>
        /// Compiles a complete class.
        /// </summary>
        private void CompileClass()
        {
            methodNames = Token.GetMethodsInClass(); 

            SymbolTable.StartClass();
            
            // Parse CLASS keyword.
            if (AdvanceIfMoreTokens() && tokenType == Token_Type.KEYWORD && tokenizer.Keyword() == Keyword.CLASS)
            {
                // Parse className.
                if (AdvanceIfMoreTokens() && tokenType == Token_Type.IDENTIFIER)
                {
                    currClassName = tokenizer.CurrentToken;
                    CompileClassBody();                    
                }
                else
                {
                    throw new Exception("Invalid class name.");
                }
            }
            else
            {
                throw new Exception("Unexpected end of file.");
            }                                                       
        }        

        /// <summary>
        /// Compiles the body of a class.
        /// </summary>
        private void CompileClassBody()
        {
            // Parse symbol '{'.
            CompileSymbol(true, Symbol.OpeningCurlyBracket, "'{' expected in class declaration.");

            bool isKeyword = true;
            Keyword keyword;
            // Parse classVarDec*.
            while (AdvanceIfMoreTokens())
            {
                if (tokenType == Token_Type.KEYWORD)
                {
                    keyword = tokenizer.Keyword();
                    if (keyword == Keyword.STATIC || keyword == Keyword.FIELD)
                    {
                        // Compile classVarDec i.e. a static declaration or a field declaration.
                        CompileVarListWithTerminator();                        
                    }
                    else
                    {
                        break;
                    }
                }
                else
                {
                    isKeyword = false;
                    break;
                }
            }            

            if (isKeyword)
            {
                // Parse subroutineDec*.
                do
                {
                    keyword = tokenizer.Keyword();
                    if (keyword == Keyword.CONSTRUCTOR || keyword == Keyword.FUNCTION || keyword == Keyword.METHOD)
                    {
                        currSubroutine.Kind = keyword;
                        CompileSubroutine();
                    }
                    else
                    {
                        break;
                    }
                }
                while (AdvanceIfMoreTokens() && tokenType == Token_Type.KEYWORD);
            }

            // Parse symbol '}'.
            CompileSymbol(false, Symbol.ClosingCurlyBracket, "'}' expected in class declaration."); 
        }

        /// <summary>
        /// Compiles a complete method, function, or constructor.
        /// </summary>
        private void CompileSubroutine()
        {
            Keyword subroutineType = currSubroutine.Kind;
            bool isMethod = false;            
            if (subroutineType == Keyword.METHOD)
            {
                isMethod = true;
            }
            // If subroutine is method, first argument is the current object.
            // Hence, need to set runningIndex=runningIndex+1 for each argument in the list of arguments.
            SymbolTable.StartSubroutine(isMethod);
            currSubroutine.IfLabelIndex = 0;
            currSubroutine.WhileLabelIndex = 0;

            // Parse 'void'|type.
            if (AdvanceIfMoreTokens())
            {                
                if (tokenType == Token_Type.KEYWORD && tokenizer.Keyword() == Keyword.VOID)
                {
                    currSubroutine.IsVoid = true;
                }
                else if (IsValidType())
                {
                    currSubroutine.IsVoid = false;               
                }
                else
                {
                    throw new Exception("Invalid subroutine type.");
                }
            }
            else
            {
                throw new Exception("Subroutine type expected.");
            }

            // Parse subroutineName.
            if (AdvanceIfMoreTokens() && tokenType == Token_Type.IDENTIFIER)
            {
                currSubroutine.Name = currClassName + "." + tokenizer.CurrentToken;                               
            }
            else
            {
                throw new Exception("Invalid subroutine name.");
            }

            // Parse symbol '('.
            CompileSymbol(true, Symbol.OpeningRoundBracket, "'(' expected in subroutine declaration.");

            // Parse: ((type varName) (',' type varName)*)?.
            CompileParameterList();

            // Parse symbol ')'.
            CompileSymbol(false, Symbol.ClosingRoundBracket, "')' expected in variable declaration.");

            CompileSubroutineBody();
        }

        /// <summary>
        /// Compiles a (possibly empty) parameter list, not including the enclosing “()”. 
        /// </summary>
        private void CompileParameterList()
        {            
            // Parse type.
            if (AdvanceIfMoreTokens() && IsValidType())
            {                
                string listVarType = tokenizer.CurrentToken;               

                // Parse varName.
                if (AdvanceIfMoreTokens() && tokenType == Token_Type.IDENTIFIER)
                {
                    SymbolTable.Define(tokenizer.CurrentToken, listVarType, IdentifierCategory.ARG);                                       
                }
                else
                {
                    throw new Exception("Identifier expected in parameter list.");
                }

                // Parse (',' type varName)*.
                while (AdvanceIfMoreTokens())
                {
                    if (tokenType == Token_Type.SYMBOL && tokenizer.Symbol() == Symbol.Comma)
                    {                        
                        if (AdvanceIfMoreTokens() && IsValidType())
                        {
                            listVarType = tokenizer.CurrentToken;
                            if (AdvanceIfMoreTokens() && tokenType == Token_Type.IDENTIFIER)
                            {
                                SymbolTable.Define(tokenizer.CurrentToken, listVarType, IdentifierCategory.ARG);
                            }
                            else
                            {
                                throw new Exception("Identifier expected in parameter list.");
                            }
                        }
                        else
                        {
                            throw new Exception("Invalid parameter list.");
                        }
                    }
                    else
                    {
                        break;
                    }
                }
            }
        }

        /// <summary>
        /// Compiles the body of a method, function, or constructor.
        /// </summary>        
        private void CompileSubroutineBody()
        {
            // Parse symbol '{'.
            CompileSymbol(true, Symbol.OpeningCurlyBracket, "'{' expected in subroutine declaration.");            

            // Parse varDec*.
            while (AdvanceIfMoreTokens())
            {
                if (tokenType == Token_Type.KEYWORD)
                {                   
                    if (tokenizer.Keyword() == Keyword.VAR)
                    {
                        CompileVarListWithTerminator();
                    }
                    else
                    {
                        break;
                    }
                }
                else
                {
                    break;
                }
            }

            // Writes the function declaration.
            int nArgs = SymbolTable.VarCount(IdentifierCategory.VAR);
            writer.WriteFunction(currSubroutine.Name, nArgs);

            WriteSubroutineInitializationCode();

            // Parse statements.
            CompileStatements();

            // Parse symbol '}'.
            CompileSymbol(false, Symbol.ClosingCurlyBracket, "'}' expected in subroutine body declaration.");
        }
        
        #endregion

        #region StatementRules

        /// <summary>
        /// Compiles a sequence of statements, not including the enclosing “{}”. 
        /// </summary>
        private void CompileStatements()
        {
            // Parse statement*.
            do
            {
                if (tokenType == Token_Type.KEYWORD)
                {
                    Keyword keyword = tokenizer.Keyword();
                    
                    if (keyword == Keyword.LET)
                    {
                        CompileLet();
                    }
                    else if (keyword == Keyword.IF)
                    {
                        CompileIf();                        
                    }
                    else if (keyword == Keyword.WHILE)
                    {
                        CompileWhile();
                    }
                    else if (keyword == Keyword.DO)
                    {
                        CompileDo();
                    }
                    else if (keyword == Keyword.RETURN)
                    {
                        CompileReturn();
                    }
                    else
                    {
                        break;
                    }
                }
                else
                {
                    break;
                }
            }
            while (AdvanceIfMoreTokens());            
        }

        /// <summary>
        /// Compiles a LET statement. 
        /// </summary>
        private void CompileLet()
        {
            IdentifierCategory idenCat;
            int idenIndex;
            string letVarName;

            // Parse varName.
            if (AdvanceIfMoreTokens() && tokenType == Token_Type.IDENTIFIER)
            {                
                letVarName = tokenizer.CurrentToken;
                CheckThatIdentifierExists(letVarName, out idenCat, out idenIndex);
            }
            else
            {
                throw new Exception("Invalid LET statement declaration.");
            }

            bool advanceToken = false;
            // Parse ('['expression']')?.
            // Parse symbol '['.
            if (AdvanceIfMoreTokens() && tokenType == Token_Type.SYMBOL && tokenizer.Symbol() == Symbol.OpeningSquareBracket)
            {
                CheckThatVarIsArray(letVarName);
                // Parse expression.                
                CompileExpression();
                // Parse symbol ']'.
                CompileSymbol(false, Symbol.ClosingSquareBracket, "Invalid LET statement declaration.");
                advanceToken = true;

                // Pop the result of the expression evaluation in the TEMP segment.
                // This result is needed later to get the array entry that is supposed to be set in the LET statement.
                writer.WritePop(VM_Segment.Temp, 7);
            }

            // Parse symbol '='.
            CompileSymbol(advanceToken, Symbol.EqualSign, "'=' expected in LET statement declaration.");

            // Parse expression.
            CompileExpression();

            // Parse symbol ';'.
            CompileSymbol(false, Symbol.Semicolon, "';' expected in LET statement declaration.");

            // If LET_statement_LHS = varName[expression], set the corresponding array entry.
            if (advanceToken)
            {
                // Set the value of varName[expression].
                WriteSetArrayEntry(idenCat, idenIndex, VM_Segment.Temp, 7);
            }
            else
            {
                // LET_statement_LHS = varName.
                // Set the value of varName.
                VM_Segment vmSegment = VMWriter.idenCatToVMSegment[idenCat];
                writer.WritePop(vmSegment, idenIndex);
            }
        }

        /// <summary>
        /// Compiles an IF statement, possibly with a trailing ELSE clause.
        /// </summary>
        private void CompileIf()
        {
            string ifLabelIndex = currSubroutine.IfLabelIndex.ToString();
            currSubroutine.IfLabelIndex++;                        
            
            string ifFalseLabel = ifFalseLabelConst + ifLabelIndex;
            // Parse '('expression')'.            
            CompileExpressionWithinRoundBrackets(true);
            // At this point, the stack top is the result of the expression evaluation.
            writer.WriteArithmetic(Arithmetic_Command.Not);
            writer.WriteIf(ifFalseLabel);

            // Parse '{'statements'}'.
            CompileStatementsWithinCurlyBrackets();                       

            // An ELSE clause may appear 0 or 1 time. Regardless, at the end of this function, the current token must have
            // been processed. That's why a peek to the next token is needed.
            // The tokenizer advances only if the next token is 'else'.
            // Parse: ('else' '{'statements'}')?.
            if (tokenizer.HasMoreTokens())
            {
                KeyValuePair<string, Token_Type> nextToken = tokenizer.Peek();
                string nextTokenString = nextToken.Key;
                Token_Type nextTokenType = nextToken.Value;
                if (nextTokenType == Token_Type.KEYWORD && tokenizer.PeekKeyword(nextTokenString) == Keyword.ELSE)
                {
                    // There's an ELSE clause.
                    string ifEndLabel = ifEndLabelConst + ifLabelIndex;
                    writer.WriteGoto(ifEndLabel);
                    writer.WriteLabel(ifFalseLabel);
                    tokenizer.Advance();
                    // Parse '{'statements'}'.
                    CompileStatementsWithinCurlyBrackets();

                    writer.WriteLabel(ifEndLabel);
                }
                else
                {
                    // There's no ELSE clause.
                    writer.WriteLabel(ifFalseLabel);
                }
            }            
        }

        /// <summary>
        /// Compiles a WHILE statement.
        /// </summary>
        private void CompileWhile()
        {
            string whileLabelIndex = currSubroutine.WhileLabelIndex.ToString();
            currSubroutine.WhileLabelIndex++;

            string whileStartLabel = whileStartLabelConst + whileLabelIndex;
            string whileEndLabel = whileEndLabelConst + whileLabelIndex;

            writer.WriteLabel(whileStartLabel);
            // Parse '('expression')'.            
            CompileExpressionWithinRoundBrackets(true);
            // At this point, the stack top is the result of the expression evaluation.
            writer.WriteArithmetic(Arithmetic_Command.Not);

            writer.WriteIf(whileEndLabel);
            // Parse '{'statements'}'.
            CompileStatementsWithinCurlyBrackets();

            writer.WriteGoto(whileStartLabel);
            writer.WriteLabel(whileEndLabel);
        }

        /// <summary>
        /// Compiles a DO statement.
        /// </summary>
        private void CompileDo()
        {
            // Parse subroutine call.
            CompileSubroutineCall(true);
            // Parse symbol ';'.
            CompileSymbol(true, Symbol.Semicolon, "';' expected in DO statement declaration.");
        }

        /// <summary>
        /// Compiles a RETURN statement.
        /// </summary>        
        private void CompileReturn()
        {            
            bool advanceToken = true;
            // Parse expression?.
            if (IsValidExpressionStart())
            {
                // Parse expression.
                CompileExpression();
                advanceToken = false;
            }

            if (currSubroutine.IsVoid)
            {
                // If the RETURN statement contains an expression
                if (!advanceToken)
                {
                    throw new Exception("Since " + currSubroutine.Name + " returns void, " +
                        "a return keyword must not be followed by an object expression.");
                }
                else
                {
                    // VM functions corresponding to void Jack methods and functions must return the
                    // constant 0 as their return value.
                    writer.WritePush(VM.VM_Segment.Constant, 0);
                }
            }
            else
            {
                // If the RETURN statement contains no expression
                if (advanceToken)
                {
                    throw new Exception("'" + currSubroutine.Name + "': not all code paths return a value.");
                }
            }

            // Parse symbol ';'.
            CompileSymbol(advanceToken, Symbol.Semicolon, "';' expected in RETURN statement declaration.");

            writer.WriteReturn();            
        }

        #endregion

        #region ExpressionRules

        /// <summary>
        /// Compiles an expression.
        /// </summary>
        private void CompileExpression()
        {
            // Parse term.
            CompileTerm();

            // Parse (op term)*.
            while (AdvanceIfMoreTokens())
            {
                string vmFct;
                Arithmetic_Command aritComm;
                if (tokenType == Token_Type.SYMBOL && IsOp(out vmFct, out aritComm))
                {                    
                    CompileTerm();
                    if (aritComm != Arithmetic_Command.None)
                    {
                        writer.WriteArithmetic(aritComm);
                    }
                    else
                    {
                        writer.WriteCall(vmFct, 2);
                    }
                }
                else
                {
                    break;
                }
            }            
        }

        /// <summary>
        /// Compiles a term.
        /// </summary>
        private void CompileTerm()
        {
            // Parse 
            // integerConstant | stringConstant | keywordConstant | varName |
            // varName '[' expression ']' | subroutineCall | '(' expression ')' | unaryOp term.
            if (AdvanceIfMoreTokens())
            {
                Token_Type tokenType = tokenizer.TokenType();
                
                if (tokenType == Token_Type.INT_CONST)
                {
                    writer.WritePush(VM_Segment.Constant, tokenizer.IntVal());                    
                }
                else if(tokenType == Token_Type.STRING_CONST)
                {
                    WriteCreateStringConstant(tokenizer.StringVal());                    
                }
                else if (tokenType == Token_Type.KEYWORD)
                {
                    if (!TryWriteCreateKeywordConstant())
                    {
                        throw new Exception("Invalid keyword constant.");
                    }
                }
                else if (tokenType == Token_Type.IDENTIFIER)
                {
                    CompileTermBeginningWithIdentifier();                 
                }
                else if (tokenType == Token_Type.SYMBOL)
                {
                    Arithmetic_Command aritComm;
                    if (tokenizer.Symbol() == Symbol.OpeningRoundBracket)
                    {
                        // Parse '(' expression ')'.
                        CompileExpressionWithinRoundBrackets(false);
                    }
                    else if (IsUnaryOp(out aritComm))
                    {
                        // Parse unaryOp term.
                        CompileTerm();
                        writer.WriteArithmetic(aritComm);
                    }
                    else
                    {
                        throw new Exception("Invalid term.");
                    }
                }
                else
                {
                    throw new Exception("Invalid term.");
                }
            }
            else
            {
                throw new Exception("Term expected in expression declaration.");
            }
        }        

        /// <summary>
        /// Compiles a subroutine call.
        /// This method needs to call <see cref="AdvanceIfMoreTokens()"/> if the current token has been processed.
        /// Otherwise, it can process the current token.
        /// </summary>
        /// <param name="advanceToken"> True, if the tokenizer needs to advance to the next token; false, otherwise.</param>
        private void CompileSubroutineCall(bool advanceToken)
        {
            bool hasMoreTokens = IfAdvanceToken(advanceToken);

            // Parse: subroutineName|className|varName.
            if (hasMoreTokens && tokenType == Token_Type.IDENTIFIER)
            {                
                string idenName = tokenizer.CurrentToken;
                if (AdvanceIfMoreTokens())
                {
                    // Parse symbol '.'.
                    if (tokenType == Token_Type.SYMBOL && tokenizer.Symbol() == Symbol.Period)
                    {
                        // At this point, the identifier is either className or varName.
                        IdentifierCategory idenCat;
                        int idenIndex;
                        // If the identifier exists in the symbol table, it's a varName.
                        bool isVarName = TryGetIdentifierInfo(idenName, out idenCat, out idenIndex);

                        if (isVarName)
                        {                            
                            // The identifier is varName.
                            VM_Segment vmSegment = VMWriter.idenCatToVMSegment[idenCat];
                            // Need to push, as first argument, a reference to the object on which
                            // the method is supposed to operate.
                            writer.WritePush(vmSegment, idenIndex);

                            string varType = SymbolTable.TypeOf(idenName);
                            // Parse: subroutineName'('expressionList')'.
                            CompileSubroutineNameWithExpressionList(varType: varType);
                        }
                        else
                        {
                            // The identifier is className.
                            // Parse: subroutineName '('expressionList')'.
                            CompileSubroutineNameWithExpressionList(className: idenName);
                        }                        
                    }
                    else
                    {
                        int expCount = 0;
                        // If the subroutine is a method.
                        if (methodNames.Contains(idenName))
                        {
                            // Need to push, as first argument, a reference to the object on which
                            // the method is supposed to operate i.e. THIS.
                            writer.WritePush(VM_Segment.Pointer, 0);
                            expCount++;
                        }

                        // The identifier is subroutineName.
                        // Parse '('expressionList')'.                                                
                        expCount += CompileExpressionListWithinRoundBrackets();                                               
                        writer.WriteCall(currClassName + "." + idenName, expCount);

                        // If the subroutine returns void, it pushes 0 onto the stack.
                        // The return value must be popped out of the stack to avoid running out of segment space.
                        if (Token.voidSubroutineNames[currClassName].Contains(idenName))
                        {
                            writer.WritePop(VM_Segment.Temp, 0);
                        }
                    }
                }
                else
                {
                    throw new Exception("'.' or '(' expected in subroutine call.");
                }
            }
            else
            {
                throw new Exception("Invalid subroutine call.");
            }
        }

        /// <summary>
        /// Compiles a (possibly empty) comma-separated list of expressions.
        /// </summary>
        /// <param name="tokenAdvance"> Remembers if the tokenizer needs to advance when this subroutine returns.</param>
        /// <returns> The number of expressions in the list.</returns>
        private int CompileExpressionList(out bool tokenAdvance)
        {
            int expressionCount = 0;
            tokenAdvance = true;
            // Parse (expression (',' expression)*)?.
            if (IsValidExpressionStart())
            {
                tokenAdvance = false;

                // Parse expression.
                CompileExpression();
                expressionCount++;

                // Parse (',' expression)*.
                do
                {
                    if (tokenType == Token_Type.SYMBOL && tokenizer.Symbol() == Symbol.Comma)
                    {                        
                        // Parse expression.
                        CompileExpression();
                        expressionCount++;
                    }
                    else
                    {                        
                        break;
                    }
                }
                while (tokenizer.HasMoreTokens());
            }

            return expressionCount;
        }

        #endregion

        #region HelperMethods

        /// <summary>
        /// If there are more tokens in the file, advances the tokenizer and gets the type of the current token.
        /// </summary>
        /// <returns> True, if there are more tokens; false, otherwise.</returns>
        private bool AdvanceIfMoreTokens()
        {
            if (tokenizer.HasMoreTokens())
            {
                tokenizer.Advance();
                tokenType = tokenizer.TokenType();
                return true;
            }

            return false;
        }

        /// <summary>
        /// Checks if the tokenizer can advance (if it needs to) to the next token.
        /// </summary>
        /// <param name="advanceToken"> True, if the tokenizer needs to advance to the next token; false, otherwise.</param>
        /// <returns> True, if the tokenizer needs to and can advance to the next token; false, otherwise.</returns>
        private bool IfAdvanceToken(bool advanceToken)
        {
            if (advanceToken && !AdvanceIfMoreTokens())
            {
                return false;
            }
            return true;
        }       

        #region MethodsForCheckingDuplicateVars
        ///// <summary>
        ///// Tries to store the identifier info in the symbol table, based on the specified parameters.
        ///// </summary>
        ///// <param name="idenName"> The identifier name.</param>
        ///// <param name="idenCatString"> The identifier category string.</param>
        ///// <param name="idenIndex"> The identifier running index.</param>
        ///// <returns> True, if identifier info is not present in the symbol table; false, otherwise.</returns>
        //private bool TryStoreIdentifierInfo(string idenName, string idenDataType, IdentifierCategory idenCat)
        //{
        //    IdentifierCategory idenKind = SymbolTable.KindOf(idenName);
        //    if (idenKind == IdentifierCategory.NONE)
        //    {
        //        SymbolTable.Define(idenName, idenDataType, idenCat);
        //        return true;
        //    }
        //    return false;
        //}

        ///// <summary>
        ///// If the identifier specified by the given parameters doesn't exist in the symbol table (i.e. it's not a duplicate),
        ///// adds this identifier info to the symbol table and writes it to the XML.
        ///// Else, throws an exception.
        ///// </summary>
        ///// <param name="idenName"> The identifier name.</param>
        ///// <param name="idenDataType"> The identifier data type.</param>
        ///// <param name="idenCat"> The identifier category.</param>
        ///// <param name="idenCatString"> The identifier category string.</param>
        ///// <param name="isIdenDefined"> The identifier status: defined or used.</param>
        ///// <param name="exMessage"> The exception message to be displayed in case the identifier is a duplicate.</param>
        //private void StoreAndWriteIdentifierIfItsNotDuplicate(string idenName, string idenDataType, IdentifierCategory idenCat,
        //    string idenCatString, bool isIdenDefined, string exMessage="")
        //{
        //    bool isNotDuplicate = TryStoreIdentifierInfo(idenName, idenDataType, idenCat);
        //    if (isNotDuplicate)
        //    {                
        //        WriteIdentifier(idenName, idenCatString, isIdenDefined, SymbolTable.IndexOf(idenName));
        //    }
        //    else
        //    {
        //        throw new Exception(exMessage);
        //    }
        //}
        #endregion       

        /// <summary>
        /// Tries to retrieve the identifier info from the symbol table, based on the specified parameter.
        /// </summary>
        /// <param name="idenName"> The identifier name.</param>
        /// <param name="idenCat"> The identifier category.</param>
        /// <param name="idenIndex"> The identifier running index.</param>
        /// <returns> True, if identifier info is successfully retrieved; false, otherwise.</returns>
        private bool TryGetIdentifierInfo(string idenName, out IdentifierCategory idenCat, out int idenIndex)
        {            
            idenIndex = -1;
            idenCat = SymbolTable.KindOf(idenName);
            if (idenCat != IdentifierCategory.NONE)
            {                
                idenIndex = SymbolTable.IndexOf(idenName);
                return true;
            }

            return false;
        }

        /// <summary>
        /// Checks that the identifier specified by the given parameters exists in the symbol table
        /// i.e. is accessible in the current scope.
        /// Throws an exception if the identifier is not found. 
        /// </summary>
        /// <param name="idenName"> The identifier name.</param>
        /// <param name="idenCat"> The identifier category.</param>
        /// <param name="idenIndex"> The identifier running index.</param>    
        private void CheckThatIdentifierExists(string idenName, out IdentifierCategory idenCat, out int idenIndex)
        {
            bool idenIsDefined = TryGetIdentifierInfo(idenName, out idenCat, out idenIndex);
            if (!idenIsDefined)
            {
                throw new Exception("The name " + idenName + " does not exist in the current context.");
            }
        }

        /// <summary>
        /// Checks that the variable specified by the given parameters is accessible in the current scope.
        /// If it is, pushes its value onto the stack.
        /// </summary>
        /// <param name="idenName"> The identifier name.</param>
        /// <param name="idenCat"> The identifier category.</param>
        /// <param name="idenIndex"> The identifier running index.</param>
        private void CheckThatVarExistsAndPushValueOntoStack(string idenName)
        {
            IdentifierCategory idenCat;
            int idenIndex;
            CheckThatIdentifierExists(idenName, out idenCat, out idenIndex);
            VM_Segment vmSegment = VMWriter.idenCatToVMSegment[idenCat];
            writer.WritePush(vmSegment, idenIndex);
        }

        /// <summary>
        /// Checks that the variable with the specified name represents an array.
        /// Throws an exception if it doesn't.
        /// </summary>
        /// <param name="varName"> The variable name.</param>
        private void CheckThatVarIsArray(string varName)
        {
            string type = SymbolTable.TypeOf(varName);
            if (type != "Array")
            {
                throw new Exception("Cannot apply indexing with [] to an expression of type '" + type + "'.");
            }
        }

        /// <summary>
        /// Compiles the symbol represented by the current token.
        /// This method needs to call <see cref="AdvanceIfMoreTokens()"/> if the current token has been processed.
        /// Otherwise, it can process the current token.
        /// </summary>
        /// <param name="advanceToken"> True, if the tokenizer needs to advance to the next token; false, otherwise.</param>
        /// <param name="symbol"> The Jack symbol to be parsed.</param>
        /// <param name="exMessage"> The exception message to be displayed in case the compilation fails.</param>
        private void CompileSymbol(bool advanceToken, Symbol symbol, string exMessage)
        {
            bool hasMoreTokens = IfAdvanceToken(advanceToken);

            if (!(hasMoreTokens && tokenType == Token_Type.SYMBOL && tokenizer.Symbol() == symbol))
            {
                throw new Exception(exMessage);
            }
        }
        
        /// <summary>
        /// Checks if the current token is a binary operator.
        /// </summary>
        /// <param name="vmFct"> The function name in case the operator is '*' or '/'.</param>
        /// <param name="aritComm"> The arithmetic command in case the operator corresponds to one.</param>
        /// <returns> True, if the current token is a binary operator; false, otherwise.</returns>
        private bool IsOp(out string vmFct, out Arithmetic_Command aritComm)
        {
            vmFct = "";
            aritComm = Arithmetic_Command.None;
            bool isOp = true;

            Symbol op = tokenizer.Symbol();
            if(op == Symbol.Asterisk)
            {
                vmFct = "Math.multiply";
            }
            else if (op == Symbol.Slash)
            {
                vmFct = "Math.divide";
            }            
            else
            {
                isOp = Token.binaryAritCommands.TryGetValue(op, out aritComm);
            }            

            return isOp;
        }
        
        /// <summary>
        /// Checks if the current token is a unary operator.
        /// </summary>
        /// <param name="aritComm"> The arithmetic command in case the operator corresponds to one.</param>
        /// <returns> True, if the current token is a unary operator; false, otherwise.</returns>
        private bool IsUnaryOp(out Arithmetic_Command aritComm)
        {
            aritComm = Arithmetic_Command.None;
            bool isUnOp = true;

            Symbol unaryOp = tokenizer.Symbol();
            if (unaryOp == Symbol.MinusSign)
            {
                aritComm = Arithmetic_Command.Neg;
            }
            else if (unaryOp == Symbol.Tilde)
            {
                aritComm = Arithmetic_Command.Not;
            }
            else
            {
                isUnOp = false;
            }

            return isUnOp;
        }

        /// <summary>
        /// Checks if the current token is a keyword constant i.e. TRUE, FALSE, NULL or THIS.
        /// Creates an in-memory keyword constant on the stack top, if it is.        
        /// </summary>
        /// <returns> True, if the current token is a keyword constant; false, otherwise.</returns>
        private bool TryWriteCreateKeywordConstant()
        {
            bool isKwCt = true;
            Keyword ct = tokenizer.Keyword();
            if (ct == Keyword.TRUE)
            {
                // TRUE is mapped to the constant -1.
                writer.WritePush(VM_Segment.Constant, 0);
                writer.WriteArithmetic(Arithmetic_Command.Not);
            }
            else if (ct == Keyword.FALSE || ct == Keyword.NULL)
            {
                // FALSE and NULL are mapped to the constant 0.
                writer.WritePush(VM_Segment.Constant, 0);
            }
            else if (ct == Keyword.THIS)
            {
                writer.WritePush(VM_Segment.Pointer, 0);
            }
            else
            {
                isKwCt = false;
            }

            return isKwCt;
        }
                
        /// <summary>
        /// Tries to compile a list of variables.
        /// </summary>        
        /// <returns> True, if the list of variables is valid; false, otherwise.</returns>
        private bool TryCompileVarList()
        {
            // The data type of the variables in the list.
            string listVarType;
            // This string is 'static'|'field' (if the list var is part of classVarDec) or 
            // 'var' (if the list var is part of varDec).
            string listVarKind = tokenizer.CurrentToken;

            // Parse type.
            if (AdvanceIfMoreTokens() && IsValidType())
            {
                listVarType = tokenizer.CurrentToken;
                IdentifierCategory idenCategory = Token.idenStringToCatDictionary[listVarKind];

                // Parse varName.
                if (AdvanceIfMoreTokens() && tokenType == Token_Type.IDENTIFIER)
                {
                    SymbolTable.Define(tokenizer.CurrentToken, listVarType, idenCategory);                   
                }
                else
                {
                    return false;
                }

                // Parse (',' varName)*.
                while (AdvanceIfMoreTokens())
                {
                    if (tokenType == Token_Type.SYMBOL && tokenizer.Symbol() == Symbol.Comma)
                    {                        
                        if (AdvanceIfMoreTokens() && tokenType == Token_Type.IDENTIFIER)
                        {
                            SymbolTable.Define(tokenizer.CurrentToken, listVarType, idenCategory);                            
                        }
                        else
                        {
                            return false;
                        }
                    }
                    else
                    {
                        break;
                    }
                }
            }
            else
            {
                return false;
            }            

            return true;
        }

        /// <summary>
        /// Checks the validity of the type represented by the current token.
        /// </summary>
        /// <returns> True, if type is valid; false, otherwise.</returns>
        private bool IsValidType()
        {
            // Parse 'int'|'char'|'boolean'|className.
            if (tokenType == Token_Type.KEYWORD)
            {
                Keyword keyword = tokenizer.Keyword();
                if (keyword == Keyword.INT || keyword == Keyword.CHAR || keyword == Keyword.BOOLEAN)
                {                  
                    return true;
                }
            }
            else if (tokenType == Token_Type.IDENTIFIER)
            {               
                return true;
            }

            return false;
        }

        /// <summary>
        /// Checks if the next token is a valid expression start.
        /// </summary>
        /// <returns> True, if the start of the expression is valid; false, otherwise.</returns>
        private bool IsValidExpressionStart()
        {
            // Get a look-ahead token if there are more tokens.
            if (tokenizer.HasMoreTokens())
            {
                KeyValuePair<string, Token_Type> nextToken = tokenizer.Peek();
                string nextTokenString = nextToken.Key;
                Token_Type nextTokenType = nextToken.Value;

                // A valid expression can start with any token (with the exceptions below) of a valid type.
                if (nextTokenType != Token_Type.ERROR)
                {
                    if (nextTokenType == Token_Type.SYMBOL)
                    {
                        Symbol nextTokenSymbol = tokenizer.PeekSymbol(nextTokenString);
                        // If the expression starts with a symbol, it must be '(', '-' or '~'.
                        if (nextTokenSymbol != Symbol.OpeningRoundBracket && nextTokenSymbol != Symbol.MinusSign &&
                            nextTokenSymbol != Symbol.Tilde)
                        {
                            return false;
                        }
                    }

                    if (nextTokenType == Token_Type.KEYWORD)
                    {
                        Keyword nextTokenKeyword = tokenizer.PeekKeyword(nextTokenString);
                        // If the expression starts with a keyword, it must be 'true', 'false', 'null' or 'this'.
                        if (nextTokenKeyword != Keyword.TRUE && nextTokenKeyword != Keyword.FALSE &&
                            nextTokenKeyword != Keyword.NULL && nextTokenKeyword != Keyword.THIS)
                        {
                            return false;
                        }
                    }

                    return true;
                }
            }

            return false;
        }

        /// <summary>
        /// Compiles a declaration of a list of variables appended with a semicolon.
        /// </summary>
        private void CompileVarListWithTerminator()
        {
            // Parse: type varName (',' varName)* ';'.
            bool isVarList = TryCompileVarList();
            if (!isVarList)
            {
                throw new Exception("Invalid variable declaration.");
            }
            else
            {
                // Parse symbol ';'.
                CompileSymbol(false, Symbol.Semicolon, "';' expected in variable declaration.");
            }
        }

        /// <summary>
        /// Compiles an expression enclosed within round brackets.
        /// This method needs to call <see cref="AdvanceIfMoreTokens()"/> if the current token has been processed.
        /// Otherwise, it can process the current token.
        /// </summary>
        /// <param name="advanceToken"> True, if the tokenizer needs to advance to the next token; false, otherwise.</param>
        private void CompileExpressionWithinRoundBrackets(bool advanceToken)
        {
            // Parse '('expression')'.
            CompileSymbol(advanceToken, Symbol.OpeningRoundBracket, "'(' expected in statement declaration.");
            CompileExpression();
            CompileSymbol(false, Symbol.ClosingRoundBracket, "')' expected in statement declaration.");
        }

        /// <summary>
        /// Compiles an expression enclosed within square brackets.
        /// </summary>
        private void CompileExpressionWithinSquareBrackets()
        {
            // Parse '('expression')'.
            CompileSymbol(true, Symbol.OpeningSquareBracket, "'[' expected in statement declaration.");
            CompileExpression();
            CompileSymbol(false, Symbol.ClosingSquareBracket, "']' expected in statement declaration.");
        }

        /// <summary>
        /// Compiles an expressionList enclosed within round brackets.
        /// </summary>
        /// <returns> The number of expressions in the list.</returns>
        private int CompileExpressionListWithinRoundBrackets()
        {
            bool tokenAdvance;
            // Parse '('expressionList')'.
            CompileSymbol(false, Symbol.OpeningRoundBracket, "'(' expected in subroutine call.");
            int expressionCount = CompileExpressionList(out tokenAdvance);
            CompileSymbol(tokenAdvance, Symbol.ClosingRoundBracket, "')' expected in subroutine call.");

            return expressionCount;
        }

        /// <summary>
        /// Compiles statement(s) enclosed within curly brackets.
        /// </summary>
        private void CompileStatementsWithinCurlyBrackets()
        {
            // Parse '{'statements'}'.
            CompileSymbol(true, Symbol.OpeningCurlyBracket, "'{' expected in statement declaration.");
            if (AdvanceIfMoreTokens())
            {
                CompileStatements();
            }            
            CompileSymbol(false, Symbol.ClosingCurlyBracket, "'}' expected in statement declaration.");
        }        

        /// <summary>
        /// Compiles the syntactic construct (subroutine name followed by argument list) of a subroutine call.
        /// </summary>
        /// <param name="className"> The class name, in case the subroutine is a function.</param>
        private void CompileSubroutineNameWithExpressionList(string className="", string varType="")
        {
            // Parse subroutineName '('expressionList')'.
            if (AdvanceIfMoreTokens() && tokenType == Token_Type.IDENTIFIER)
            {
                string subroutineName, fullSubroutineName;
                subroutineName = tokenizer.CurrentToken;
                
                if (AdvanceIfMoreTokens())
                {
                    int expCount = CompileExpressionListWithinRoundBrackets();
                    // The called subroutine is a method, invoked by an object.                    
                    if (string.IsNullOrEmpty(className))
                    {
                        // varType is the className of the field that calls the subroutine.
                        className = varType;
                        // A Jack method with k arguments is compiled into a VM function that operates on k+1 arguments.
                        // The first argument (argument number 0) always refers to the THIS object.
                        expCount++;
                    }

                    fullSubroutineName = className + "." + subroutineName;
                    writer.WriteCall(fullSubroutineName, expCount);

                    // If the subroutine returns void, it pushes 0 onto the stack.
                    // The return value must be popped out of the stack to avoid running out of segment space.
                    if (Token.voidSubroutineNames[className].Contains(subroutineName))
                    {
                        writer.WritePop(VM_Segment.Temp, 0);
                    }
                }
                else
                {
                    throw new Exception("'(' expected in subroutine call.");
                }                
            }
            else
            {
                throw new Exception("Invalid subroutine call.");
            }
        }

        /// <summary>
        /// Compiles a term whose first token is an identifier.
        /// If the look-ahead token is “[“, the termn is an array entry.
        /// If the look-ahead token is “(“, or “.”, the term is a subroutine call.
        /// Else, the term is a var name.
        /// </summary>
        private void CompileTermBeginningWithIdentifier()
        {            
            // Get a look-ahead token to distinguish between the alternative parsing rules.
            if (tokenizer.HasMoreTokens())
            {
                string idenName = tokenizer.CurrentToken;                

                KeyValuePair<string, Token_Type> nextToken = tokenizer.Peek();
                string nextTokenString = nextToken.Key;
                Token_Type nextTokenType = nextToken.Value;
                
                if (nextTokenType != Token_Type.ERROR)
                {
                    IdentifierCategory idenCat;
                    int idenIndex;

                    if (nextTokenType == Token_Type.SYMBOL)
                    {
                        Symbol nextTokenSymbol = tokenizer.PeekSymbol(nextTokenString);
                        
                        // Array entry.
                        if (nextTokenSymbol == Symbol.OpeningSquareBracket)
                        {
                            // Parse varName.
                            CheckThatVarIsArray(idenName);                            
                            CheckThatIdentifierExists(idenName, out idenCat, out idenIndex);

                            // Parse '[' expression ']'.
                            CompileExpressionWithinSquareBrackets();

                            // Get the value of varName[expression].
                            WriteGetArrayEntry(idenCat, idenIndex);
                        }
                        // Subroutine call. 
                        else if (nextTokenSymbol == Symbol.OpeningRoundBracket || nextTokenSymbol == Symbol.Period)
                        {
                            // The tokenizer is currently at the identifier which is the first token in the subroutine call.
                            // Since <see cref="CompileSubroutineCall(bool)"/> processes this identifier,
                            // it can't be processed in the beginning of <see cref="CompileTermBeginningWithIdentifier"/>
                            // (in case the term is a var name). So, it needs to be processed separately in the case
                            // of array entry and var name.
                            // Also, there's no need for the tokenizer to advance at this point, thus the "false" parameter.
                            CompileSubroutineCall(false);
                        }
                        // Var name.
                        else
                        {
                            // Parse varName.
                            CheckThatVarExistsAndPushValueOntoStack(idenName);
                        }
                    }
                    // Var name.
                    else
                    {
                        // Parse varName.
                        CheckThatVarExistsAndPushValueOntoStack(idenName);
                    }
                }
            }
        }        

        /// <summary>
        /// If subroutineType is CONSTRUCTOR, writes VM code that allocates a memory block for the new object.
        /// If subroutineType is CONSTRUCTOR or METHOD, writes VM code that sets the base of the THIS segment properly.
        /// </summary>
        private void WriteSubroutineInitializationCode()
        {            
            Keyword subroutineType = currSubroutine.Kind;
            // Need to set the base of the THIS segment to point to the passed object.
            if (subroutineType == Keyword.METHOD)
            {
                writer.WritePush(VM_Segment.Argument, 0);
                writer.WritePop(VM_Segment.Pointer, 0);
            }
            // Need to allocate a memory block for the new object and then set the base of the THIS segment to point at its base.
            else if (subroutineType == Keyword.CONSTRUCTOR)
            {                
                int size = SymbolTable.VarCount(IdentifierCategory.FIELD);
                if (size != 0)
                {
                    writer.WritePush(VM_Segment.Constant, size);
                    writer.WriteCall("Memory.alloc", 1);
                    writer.WritePop(VM_Segment.Pointer, 0);
                }
            }
        }

        /// <summary>
        /// Creates an in-memory string constant on the stack top.
        /// </summary>
        /// <param name="s"> The string parameter.</param>
        private void WriteCreateStringConstant(string s)
        {
            int sLength = s.Length;            
            // Allocate an in-memory array to the string constant.
            writer.WritePush(VM_Segment.Constant, s.Length);
            writer.WriteCall("String.new", 1);

            // Append the characters one by one.
            foreach (char c in s)
            {
                writer.WritePush(VM_Segment.Constant, c);
                // Since String.appendChar is a method with 1 argument, it's translated into a VM function with 2 arguments.                
                writer.WriteCall("String.appendChar", 2);
            }             
        }

        /// <summary>      
        /// Gets an array entry and pushes it onto the stack.
        /// The identifier specified by the given parameters should represent an array variable.
        /// The stack top value represents the array entry index.
        /// </summary>
        /// <param name="idenCat"> The identifier category.</param>
        /// <param name="idenIndex"> The identifier running index.</param>
        private void WriteGetArrayEntry(IdentifierCategory idenCat, int idenIndex)
        {
            // Let's say we need to get the element arr[k].
            // k is the stack top at this point.
            VM_Segment vmSegment = VMWriter.idenCatToVMSegment[idenCat];
            // Push arr base address to the stack.
            writer.WritePush(vmSegment, idenIndex);
            // arr+k becomes the stack top.
            writer.WriteArithmetic(Arithmetic_Command.Add);
            // Pop the address arr+k from the stack into the THAT segment
            // so that the value found at address arr+k can be accessed.
            writer.WritePop(VM_Segment.Pointer, 1);
            // Use the THAT segment to access *(arr+k).
            writer.WritePush(VM_Segment.That, 0);           
        }

        /// <summary>
        /// Sets an array entry using the stack top value.
        /// The identifier specified by the first 2 parameters should represent an array variable.
        /// The location specified by the last 2 parameters represents the index of the array entry.    
        /// </summary>
        /// <param name="idenCat"> The identifier category.</param>
        /// <param name="idenIndex"> The identifier running index.</param>
        /// <param name="arrayEntrySegment"> The segment where the array entry index resides.</param>
        /// <param name="arrayEntrySegmentIndex"> The index in the segment where the array entry index resides.</param>
        private void WriteSetArrayEntry(IdentifierCategory idenCat, int idenIndex,
            VM_Segment arrayEntrySegment, int arrayEntrySegmentIndex)
        {
            // Let's say we need to set arr[k]=v.
            // v is the stack top at this point.
            VM_Segment vmSegment = VMWriter.idenCatToVMSegment[idenCat];
            // Push arr base address to the stack.
            writer.WritePush(vmSegment, idenIndex);
            // Push k to the stack.
            writer.WritePush(arrayEntrySegment, arrayEntrySegmentIndex);
            // arr+k becomes the stack top.
            writer.WriteArithmetic(Arithmetic_Command.Add);
            // Pop the address arr+k from the stack into the THAT segment
            // so that the value found at address arr+k can be accessed.
            writer.WritePop(VM_Segment.Pointer, 1);
            // v is the stack top again at this point.
            // Use the THAT segment to set *(arr+k)=v.
            writer.WritePop(VM_Segment.That, 0);
        }        

        /// <summary>
        /// Necessary because the class implements IDisposable.
        /// </summary>
        public void Dispose()
        {
            
        }

        #endregion
    }
}
